#include "nanobench.h"
#include <arpa/inet.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <unistd.h>

#include "DiscoveryResponse.h"

#include "CppUTest/TestHarness.h"

TEST_GROUP(DiscoveryResponseTestsGroup){ //
                                         TEST_SETUP(){}

                                         TEST_TEARDOWN(){}
};

TEST(DiscoveryResponseTestsGroup, DiscoveryResponse_serialize_deserialize_perf) {
    ankerl::nanobench::Bench b;

    b.title("DiscoveryResponse").warmup(1000).minEpochIterations(150000).relative(true);
    b.performanceCounters(true);

    uint8_t buffer[4096] = {};

    WritableACDescriptor::SubElement info_elements[] = {
        { 1234,
          ACInformationSubElementHeader::Type::HardwareVersion,
          "01234567890ABCDEF01234567890ABCDEF01234567890ABCDEF01234567890ABCDEF" },
        { 5678, ACInformationSubElementHeader::Type::SoftwareVersion, "efghijklm" },
    };
    WritableACDescriptor ac_descriptor{
        100,  200,   1000,         1234, true, false, ACDescriptorHeader::RMACField::Supported,
        true, false, info_elements
    };

    WTPRadioInformation radio_infos[] = {
        { 0, false, false, false, false },
        { 1, true, true, false, false },
        { 2, false, false, false, false },
    };

    CAPWAPControlIPv4Address ip_addresses[] = { { inet_addr("192.168.100.10"), 19 } };

    WritableVendorSpecificPayloadArray vendor_specific_payloads;
    vendor_specific_payloads.Add(12300, 700, "0123");
    vendor_specific_payloads.Add(12301, 701, "01234567");

    WritableDiscoveryResponse write_data(ac_descriptor,
                                         "Corporate-AC-1",
                                         radio_infos,
                                         ip_addresses,
                                         vendor_specific_payloads);

    b.run("serialization", [&] {
        RawData raw_data{ buffer, buffer + sizeof(buffer) };
        write_data.Serialize(&raw_data);
        ankerl::nanobench::doNotOptimizeAway(raw_data);

        raw_data = { buffer, buffer + 212 - (sizeof(ClearHeader) + sizeof(ControlHeader)) };
        ReadableDiscoveryResponse read_data;
        CHECK_TRUE(read_data.Deserialize(&raw_data));
        ankerl::nanobench::doNotOptimizeAway(raw_data);
        CHECK_EQUAL(0, read_data.unknown_elements);
    });

    const uint8_t reference[] = {
        0x00, 0x10, 0xC2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x2A, 0x00, 0x9D,
        0x00, 0x00, 0x01, 0x00, 0x69, 0x00, 0x64, 0x00, 0xC8, 0x03, 0xE8, 0x04, 0xD2, 0x02, 0x01,
        0x00, 0x02, 0x00, 0x00, 0x04, 0xD2, 0x00, 0x04, 0x00, 0x44, 0x30, 0x31, 0x32, 0x33, 0x34,
        0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x30, 0x31, 0x32,
        0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x30,
        0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x41, 0x42, 0x43, 0x44, 0x45,
        0x46, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x41, 0x42, 0x43,
        0x44, 0x45, 0x46, 0x00, 0x00, 0x16, 0x2E, 0x00, 0x05, 0x00, 0x09, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x00, 0x04, 0x00, 0x07, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72,
        0x61, 0x04, 0x18, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x18, 0x00, 0x05, 0x01,
        0x00, 0x00, 0x00, 0x03, 0x04, 0x18, 0x00, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
        0x00, 0x00, 0x00, 0x03, 0x04, 0x18, 0x00, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
        0x00, 0x00, 0x00, 0x03, 0x04, 0x18, 0x00, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
        0x00, 0x06, 0xC0, 0xA8, 0x64, 0x0A, 0x00, 0x13, 0x00, 0x13, 0xA8, 0x64, 0x0A, 0x00, 0x13,
        0x00, 0x13
    };

    b.run("reference sum", [&] {
        size_t sum = 0;
        for (size_t i = 0; i < sizeof(reference); i++) {
            sum += reference[i];
        }
        ankerl::nanobench::doNotOptimizeAway(sum);
    });
}
